// TODO: Get Ruslan's code for the csv file
// TODO: Delete CSV array testing code when Ruslan's code works
// TODO: Test all threads functioning together

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h> 
#include <sys/neutrino.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>
#include <string.h>
#include <time.h> 
#include <ctype.h>
#include <sys/time.h>
#include <signal.h>
#include <stdint.h>
#include <errno.h>  
#include <math.h>  

#define ONE_THOUSAND	1000
#define ONE_MILLION		1000000
/* offset and period are in microsends. */
#define OFFSET 1000000
#define PERIOD 5000000
#define PERIOD_TASK_SECOND 1000000
#define PERIOD_TASK_TENTH_SECOND 100000
#define PERIOD_TASK_TEN_MILLISECONDS 10000 //10000us
sigset_t sigst;

/*-------------------------Function declarations----------------------*/
void periodicTimer();
void *producerReader(void *);
static void wait_next_activation(void);
int start_periodic_timer(uint64_t offset, int period);
static void task_body(void);
void consumerDisplay();
/*-------------------------------------------------------------------*/

/*------------------------Global variables------------------------*/
double doubleCurrentTime = 0.0;
bool timerActive = true;
char filePath []= "/public/coen320/dataset.csv";
double fuelConsumption[94382];
double engineSpeed[94382];
double engineCoolantTemperature[94382];
double currentGear[94382];
double transmissionOilTemperature[94382];
double vehicleSpeed[94382];
double accelerationSpeedLongitudinal[94382];
double indicationOfBreakSwitch[94382];
/*---------------------------------------------------------------*/

//-------------------------------Test query methods--------------------------------------
char* getfield(char* line, int column)
{
    char* tok;
    for (tok = strtok(line, ","); tok && *tok; tok = strtok(NULL, ",\n"))
    {
        if (!--column){
                return tok;
        }           
    }
    return NULL;
}

void createArrayOfFuelConsumptionValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			fuelConsumption[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);		
}

void createArrayOfEngineSpeedValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			engineSpeed[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);

}
void createArrayOfEngineCoolantTemperatureValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			engineCoolantTemperature[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}


void createArrayOfCurrentGearValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			currentGear[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}
void createArrayOfTransmissionOilTemperatureValues() {
    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			transmissionOilTemperature[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}
void createArrayOfVehicleSpeedValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			vehicleSpeed[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}
void createArrayOfAccelerationSpeedLongitudinalValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			accelerationSpeedLongitudinal[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}
void createArrayOfIndicationOfBreakSwitchValues() {

    char line[1024];
    char *tmp = strdup(line);
    int location = 0;
    int count = 0;
    double myval;
    double tempHolder;
    char myvalues[94382];
    char buffer[1024];
    FILE *fp;


	fp = fopen(filePath, "r");
	if(fp != NULL){
		printf("Inside if \n");
		while(fgets(buffer, 1024, fp) != NULL){
			if(sscanf(buffer, "%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%*lf,%lf", &myval) != 1){
				printf("scan failed\n");			
			}
			indicationOfBreakSwitch[count] = myval;
			//printf("%f\n",myval);
			count++;
			//printf("count value %d\n", count);
			//mydelay(10);
			
		}
	}	
		 fclose(fp);
}
//----------------------------------------------------------------------------------------


// Struct to hold data for array when displaying in real-time in function
struct threadArgs {
   	int period;
    double array[5];	//TODO: Change to size of column from csv
    double *globalVar;
};
	
	//Global variables to display
	// TODO: Change maxVariableCount to 8 when all CSV arrays work!
	int maxVariableCount = 2;	// Use this to end main process once variableCount meets this value
	int variableCount = 0;		// Increment until max count is met, and terminate program
	
	// TODO: Add all 8 variables here
	double fuelConsumptionTest = 0;
	double engineSpeedTest = 0;
	
	int index = 0; //TODO: Remove when CSV arrays work!
	
int main ()
{
	/*Test arrays for testing purposes only*/
	double arr1[5] = {1,2,3,4,5};
	double arr2[5] = {6,7,8,9,10};
	
	/*Creating structs for variables of interest*/
	struct threadArgs* args;	// Fuel Consumption
	struct threadArgs* args2;	// Engine Speed (RPM)
	struct threadArgs* args3;	// Engine Coolant Temperature
	struct threadArgs* args4;	// Current Gear
	struct threadArgs* args5;	// Transmission Oil Temperature
	struct threadArgs* args6;	// Vehicle Speed
	struct threadArgs* args7;	// Acceleration Speed Longitudinal
	struct threadArgs* args8;	// Indication of break switch
	pthread_t	our_thread_id;
	
	// Fuel Consumption
	args = malloc(sizeof(struct threadArgs));
	args->period = 2000;
	memcpy(args->array, arr1, sizeof(arr1));	//TODO: Change to appropriate CSV array	
	args->globalVar = &fuelConsumptionTest;		
	
	// Engine Speed (RPM)
	args2 = malloc(sizeof(struct threadArgs));
	args2->period = 3000;
	memcpy(args2->array, arr2, sizeof(arr2));	//TODO: Change to appropriate CSV array
	args2->globalVar = &engineSpeedTest;
	
	// Engine Coolant Temperature
	args3 = malloc(sizeof(struct threadArgs));
	args3->period = 2000;
	memcpy(args3->array, arr2, sizeof(args3));	//TODO: Change to appropriate CSV array
	
	// Current Gear
	args4 = malloc(sizeof(struct threadArgs));
	args4->period = 2000;
	memcpy(args4->array, arr2, sizeof(args4));	//TODO: Change to appropriate CSV array
	
	// Transmission Oil Temperature
	args5 = malloc(sizeof(struct threadArgs));
	args5->period = 2000;
	memcpy(args5->array, arr2, sizeof(args5));	//TODO: Change to appropriate CSV array
	
	// Vehicle Speed
	args6 = malloc(sizeof(struct threadArgs));
	args6->period = 2000;
	memcpy(args6->array, arr2, sizeof(args6));	//TODO: Change to appropriate CSV array
	
	// Acceleration Speed Longitudinal
	args7 = malloc(sizeof(struct threadArgs));
	args7->period = 2000;
	memcpy(args7->array, arr2, sizeof(args7));	//TODO: Change to appropriate CSV array
	
	// Indication of break switchs
	args8 = malloc(sizeof(struct threadArgs));	
	args8->period = 2000;
	memcpy(args8->array, arr2, sizeof(args8));	//TODO: Change to appropriate CSV array
	
	
//	// Acquire all values from CSV and parse them into arrays
//	createArrayOfFuelConsumptionValues();
//    createArrayOfEngineSpeedValues();
//    createArrayOfEngineCoolantTemperatureValues();
//    createArrayOfCurrentGearValues();
//    createArrayOfTransmissionOilTemperatureValues();
//    createArrayOfVehicleSpeedValues();
//    createArrayOfAccelerationSpeedLongitudinalValues();
//    createArrayOfIndicationOfBreakSwitchValues();
    
    // TODO: Remove this when arrays work!
	for (index; index < 10; index++) {
        printf("Main output CG %f \n", indicationOfBreakSwitch[index]);
        printf("Main count %d \n", index);
    }
    //---------------------------------------

	// Global timer thread here
	pthread_create(&our_thread_id, NULL, &periodicTimer, NULL);
	
	// Consumer thread here
	pthread_create(NULL, NULL, &consumerDisplay, NULL);

	// Producer threads here
	pthread_create(NULL,NULL, (void *) &producerReader, args);
	pthread_create(NULL,NULL, (void *) &producerReader, args2);

	// Global timer now waiting for other threads to finish
	pthread_join(our_thread_id, NULL);	
 	pause();
	return EXIT_SUCCESS;
}

/*Read from the CSV array in real-time*/
void *producerReader(void *argPointer) {
	
	struct threadArgs *args = argPointer;
	int period = args->period;
	double* arrPtr = (args->array);
	double* varName = args->globalVar;
	double temp;
	double arr[5];		//TODO: Change to appropriate size depending on number of rows in csv
	
	// Prepare values for looping
	int arrSize = sizeof(arr)/sizeof(arr[0]);
	int executionCounter = 0;
	long nanoRemainder = 0;
	double microRemainder = 0.0;

	// Within the CSV array
	while (executionCounter < arrSize){
		double executionPeriod = (double)executionCounter * period;
		double remainder = doubleCurrentTime - executionPeriod;
			
		while (1) {
			if (remainder > -10 && remainder < 0){		
				remainder = fabs(remainder);
				
				// Get the microsecond remainder into nanoseconds
				// Take absolute value, since we are testing for long, not double
				nanoRemainder = (long)abs(remainder * 1000);	
				
				// Acquire the microsecond remainder into nanoseconds
				// Use nanoseconds for sleeping and adding back to total elapsed time
				nsleep(nanoRemainder);
				
				// Get the nanosecond value back into microseconds
				// Important because nanosecond value excludes certain decimal values
				// Microsecond would only contain the digits up until 0.00X
				microRemainder = ((double)nanoRemainder / 1000);
				
				doubleCurrentTime = doubleCurrentTime + microRemainder;
				break;
			}
			// If time is above (such as when period produced is above its expected value)
			else if (remainder >= 0) {
				break;
			}
			else {
				remainder = doubleCurrentTime - executionPeriod;
			}
		}
		
		// Get value from CSV array and set the globalVar to the current value
		temp = *(arrPtr + executionCounter);
		*varName = temp;
 		executionCounter++;		//Keep track of the number of executions 	
	}
	
	// Increment counter until all variables are complete
	// End timer when all variables are read
	variableCount++;
	if (variableCount == maxVariableCount) {
		sleep(1);	//Wait 1s for final values to appear (from consumer) before entire program terminates
		timerActive = false;	//End periodicTimer thread
	}
	free(args);	//Free memory!
	return(NULL);
}

void consumerDisplay() {
	while(1) {
		printf("-----------------------------------------------\n");
		printf("Total elapsed time double: %f\n", doubleCurrentTime);
		printf("Fuel Consumption: %f\n", fuelConsumptionTest);
		printf("Engine Speed: %f\n", engineSpeedTest);
		printf("-----------------------------------------------\n");
		nsleep(500000000);	//5ms sleep
	}
		printf("-----------------Thread functions completed!\n"); 
	
	return(NULL);
}

/*Sleep in nanoseconds*/
int nsleep(long nsec) {
    struct timespec ts;
    int res;

    if (nsec < 0)
    {
        errno = EINVAL;
        return -1;
    }

    ts.tv_sec = nsec / 1000000000L;
    ts.tv_nsec = (nsec % 1000000000L);

    do {
        res = nanosleep(&ts, &ts);
    } while (res && errno == EINTR);

    return res;
}

// Periodic timer function taken from 
// Source : COEN320 Tutorial Week 2: "Week 2: (Part 2) Implementing a periodic task [periodic_task.c]"
//---------------------Tutorial Code for Periodic Timer--------------------
// TODO: Change PERIOD with appropriate one to use for the scheduling
void periodicTimer() {
	int res;
	//set and activate a timer
	// PERIOD_TASK_SECOND = 1s
	// PERIOD_TASK_TENTH_SECOND = 0.1s
	// PERIOD_TASK_TEN_MILLISECONDS = 0.01s = 10ms
	res = start_periodic_timer(OFFSET, PERIOD_TASK_TEN_MILLISECONDS); //10ms 
	if (res < 0 ){
		perror("Start periodic timer");
		return -1;
	}
	
	while (timerActive) {
		wait_next_activation(); //wait for timer expiration
		task_body(); //executes the task
	}
	
	return(NULL);
}

static void wait_next_activation(void) {
	int dummy;
	/* suspend calling process until a signal is pending */
	sigwait(&sigst, &dummy);
}

int start_periodic_timer(uint64_t offset, int period) {
	struct itimerspec timer_spec;
	struct sigevent sigev;
	timer_t timer;
	const int signal = SIGALRM;
	int res;
	
	/* set timer parameters */
	timer_spec.it_value.tv_sec = offset / ONE_MILLION;
	timer_spec.it_value.tv_nsec = (offset % ONE_MILLION) * ONE_THOUSAND;
	timer_spec.it_interval.tv_sec = period / ONE_MILLION;
	timer_spec.it_interval.tv_nsec = (period % ONE_MILLION) * ONE_THOUSAND;
	
	sigemptyset(&sigst); // initialize a signal set
	sigaddset(&sigst, signal); // add SIGALRM to the signal set
	sigprocmask(SIG_BLOCK, &sigst, NULL); //block the signal
	
	/* set the signal event a timer expiration */
	memset(&sigev, 0, sizeof(struct sigevent));
	sigev.sigev_notify = SIGEV_SIGNAL;
	sigev.sigev_signo = signal;
	
	/* create timer */
	res = timer_create(CLOCK_MONOTONIC, &sigev, &timer);
	
	if (res < 0) {
		perror("Timer Create");
		exit(-1);
	}
	
	/* activate the timer */
	return timer_settime(timer, 0, &timer_spec, NULL);
}

static void task_body(void) {
	static int cycles = 0;
	static uint64_t start;
	uint64_t current;
	struct timespec tv;
	
	if (start == 0) {
		clock_gettime(CLOCK_MONOTONIC, &tv);
		start = tv.tv_sec * ONE_THOUSAND + tv.tv_nsec / ONE_MILLION;
	}
	
	clock_gettime(CLOCK_MONOTONIC, &tv);
	current = tv.tv_sec * ONE_THOUSAND + tv.tv_nsec / ONE_MILLION;
	
	if (cycles > 0) {
		doubleCurrentTime += (double)(current - start)/cycles;
	}
	
	cycles++;
}
//---------------------Tutorial Code for Periodic Timer--------------------


