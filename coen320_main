// TODO: Implement a second array, and test with it
// TODO: Test with other thread running and verify if arrays are printed in PROPER ORDER
// TODO: Create a function to display data, and make a thread for it to perform every period
// TODO: Get Ruslan's code for the csv file
// TODO: (Optional) Get specific row data from the CSV file to simulate a more realistic real-time approach
// TODO: Test all threads functioning together
// TODO: Clean up code

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h> 
#include <sys/neutrino.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>
#include <string.h>
#include <time.h> 
#include <ctype.h>
#include <sys/time.h>
#include <signal.h>
#include <stdint.h>
#include <errno.h>  
#include <math.h>  

#define ONE_THOUSAND	1000
#define ONE_MILLION		1000000
/* offset and period are in microsends. */
#define OFFSET 1000000
#define PERIOD 5000000
#define PERIOD_TASK_SECOND 1000000
#define PERIOD_TASK_A 10000
sigset_t sigst;


/*-------------------------Function declaration----------------------*/
int msleep(long msec);
void periodicTimer();
//void *readArr1_new(int period);
void *readArr2_new(int period);
void *readArr1_new(void *);
static void wait_next_activation(void);
int start_periodic_timer(uint64_t offset, int period);
static void task_body(void);
/*-------------------------------------------------------------------*/


/*------------------------Global variables------------------------*/
//int arr1[5] = {1,2,3,4,5};
//int arr2[5] = {6,7,8,9,10};
uint64_t currentTime = 0;
double doubleCurrentTime = 0.0;
bool timerActive = true;
// TODO: From producer thread, update the value of the variable to the new one
// TODO: From consumer thread,  publish the data in real-time
/*---------------------------------------------------------------*/


struct threadArgs {
   	int period;
    double array[5];	//TODO: Change to size of column from csv
};

struct threadArgs2 {
   	int period;
    double array[5];	//TODO: Change to size of column from csv
};


	//Uncomment using ctrl + \
	//Comment using ctrl + /
	const double arr2[5] = {6,7,8,9,10};
int main ()
{
	pthread_t	our_thread_id;
	
	const double arr1[5] = {1,2,3,4,5};
//	const double arr2[5] = {6,7,8,9,10};
	
	
	/*Creating thread1 for array1*/
	struct threadArgs* args;
	args = malloc(sizeof(struct threadArgs));
	args->period = 1000;
	memcpy(args->array, arr1, sizeof(arr1));
	
//	/*Creating thread2 for array2*/
//	struct threadArgs* args2;
//	args2 = malloc(sizeof(struct threadArgs2));
//	args2->period = 2000;
//	memcpy(args2->array, arr2, sizeof(arr2));
	
		
	
	
	
    printf("-----------------Main Timer Thread Created...\n");	
	pthread_create(&our_thread_id, NULL, &periodicTimer, NULL); 

	printf("-----------------We are now creating two threads...\n");
//	pthread_create(NULL,NULL, (void *) &readArr1, (void *) arr1);
//	pthread_create(NULL,NULL, (void *) &universalthread, (void *) 12);
		
	pthread_create(NULL,NULL, (void *) &readArr1_new, args);
	//pthread_create(NULL,NULL, (void *) &readArr2_new, (void *) 2000);

	// Main thread now waiting for other threads to finish
	pthread_join(our_thread_id, NULL);	
	printf("-----------------Thread %d completed its function!\n",our_thread_id); 
 	pause();
	return EXIT_SUCCESS;
}

// TODO: After passing the period, fetch element from csv
// TODO: Send the new variable to the consumer thread to update the variables
//void *readArr1_new(int period, double[] arr) {
void *readArr1_new(void *argPointer) {
	
	struct threadArgs *args = argPointer;
	int period = args->period;
	double* arrPtr = (args->array);
	double arr[5];		//TODO: Change to appropriate size depending on number of rows in csv
	
	// Prepare values for looping
	int arrSize = sizeof(arr)/sizeof(arr[0]);
	int executionCounter = 0;
	long nanoRemainder = 0;
	double microRemainder = 0.0;

	// TODO: Change the array arr in all instances to *(arrPtr + i) so that the array doesn't need to be recreated
	int i = 0;
	for(i; i < 5; i++) {
		arr[i] = *(arrPtr + i);
		//printf("arr: %f\n", arr[i]);
	}

	// During the array
	while (executionCounter < arrSize){
		// TODO: Fix this so that it accounts for threshold (+- 2ms abs(currentTime - executinCounter * period) 
		// TODO: or take cieling of value??
		// TODO: Test using shorter period and quicker periodic timer (i.e. 10ms)
		double executionPeriod = (double)executionCounter * period;
		double remainder = doubleCurrentTime - executionPeriod;
		
		printf("-----------------------------------------------\n");
		printf("doubleCurrentTime: %f\n", doubleCurrentTime);
		printf("executionPeriod: %f\n", executionPeriod);
		printf("remainder: %f\n", remainder);
		printf("-----------------------------------------------\n");
			
		while (1) {
			
			// TODO: Change 10 to the period the periodic counter uses!
			if (remainder > -10 && remainder < 0){		
//				printf("Remainder before abs: %f\n", remainder);
				remainder = fabs(remainder);
				
				// Get the microsecond remainder into nanoseconds
				// Take absolute value, since we are testing for long, not double
				nanoRemainder = (long)abs(remainder * 1000);	
				
				// Acquire the microsecond remainder into nanoseconds
				// Use nanoseconds for sleeping and adding back to total elapsed time
				printf("Nanoremainder: %d\n", nanoRemainder);
				nsleep(nanoRemainder);
				
				//msleep(remainder);
//				printf("Remainder after abs: %f\n", remainder);
				
				// Get the nanosecond value back into microseconds
				// Important because nanosecond value excludes certain decimal values
				// Microsecond would only contain the digits up until 0.00X
				microRemainder = ((double)nanoRemainder / 1000);
				printf("Microremainder: %f\n", microRemainder);
				
//				doubleCurrentTime = doubleCurrentTime + remainder;
				doubleCurrentTime = doubleCurrentTime + microRemainder;
				printf("DoubleCurrent Time After nsleep: %f\n", doubleCurrentTime);
				break;
			}
			else if (remainder >= 0) {
				break;
			}
			else {
				remainder = doubleCurrentTime - executionPeriod;
			}
		}
		
 		printf("From arr: %f\n", arr[executionCounter]);
 		printf("Execution counter: %d\n", executionCounter);
 		executionCounter++;		//Keep track of the number of executions 	
	}
	
	printf("arr reading complete!\n");
	//TODO: Move this into function with LONGEST LASTING period! timerActive to kill program!
	//timerActive = false;	// End timer and stop program	
	free(args);
	return(NULL);
}


//TODO: REPLACE THIS ENTIRE FUNCTION WITH NEWLY UPDATED ORIGINAL FUNCTION
//void *readArr2_new(int period) {
//	// Prepare values for looping
//	int arrSize = sizeof(arr2)/sizeof(arr2[0]);
//	int executionCounter = 0;
//	
//	// During the array
//	while (executionCounter < arrSize){
//		// TODO: Fix this so that it accounts for threshold (+- 2ms abs(currentTime - executinCounter * period) 
//		// TODO: or take cieling of value??
//		// TODO: Test using shorter period and quicker periodic timer (i.e. 10ms)
//		double executionPeriod = (double)executionCounter * period;
//		double remainder = (doubleCurrentTime - executionPeriod);
//		
//		printf("-----------------------------------------------\n");
//		printf("doubleCurrentTime: %f\n", doubleCurrentTime);
//		printf("executionPeriod: %f\n", executionPeriod);
//		printf("remainder: %f\n", remainder);
//		printf("-----------------------------------------------\n");
//			
//		while (1) {
//			// TODO: Implement msleep(remainder) to sleep for the remainder time
//			
//			// Check if there is a 5ms difference
//			// If greater than 5ms, wait
//			if (remainder > -10 && remainder < 0){		//TODO: Change 10 to the period the periodic counter uses!
//				remainder = abs(remainder);
//				//msleep(remainder);
//				doubleCurrentTime = doubleCurrentTime + remainder;
//				
//				printf("Remainder inside: %f\n", remainder);
//				printf("DoubleCurrent Time After msleep: %f\n", doubleCurrentTime);
//				break;
//			}
//			else if (remainder >= 0) {
//				printf("Remainder inside: %f\n", remainder);
//				printf("DoubleCurrent Time without msleep: %f\n", doubleCurrentTime);
//				break;
//			}
//			else {
//				remainder = doubleCurrentTime - executionPeriod;
//			}
//		}
//		
//		//TODO: Create offset value to add to currentTime after task completion, so it follows proper time
// 		printf("From arr2: %f\n", arr2[executionCounter]);
// 		printf("Execution counter: %d\n", executionCounter);
// 		executionCounter++;		//Keep track of the number of executions 	
//	}
//	
//	printf("arr reading complete!\n");
//	timerActive = false;	// End timer and stop program
//	return(NULL);
//}



////-----------------------------Sleep in milliseconds-------------------------
//int msleep(long msec) {
//    struct timespec ts;
//    int res;
//
//    if (msec < 0)
//    {
//        errno = EINVAL;
//        return -1;
//    }
//    
//    printf("Millisecond time: %d\n", msec);
//
//    ts.tv_sec = msec / 1000;
//    ts.tv_nsec = (msec % 1000) * 1000000;
//
//    do {
//        res = nanosleep(&ts, &ts);
//    } while (res && errno == EINTR);
//
//    return res;
//}

//-----------------------------Sleep in nanoseconds-------------------------
int nsleep(long nsec) {
    struct timespec ts;
    int res;

    if (nsec < 0)
    {
        errno = EINVAL;
        return -1;
    }

    ts.tv_sec = nsec / 1000000000L;
    ts.tv_nsec = (nsec % 1000000000L);

    do {
        res = nanosleep(&ts, &ts);
    } while (res && errno == EINTR);

    return res;
}

// TODO: Change PERIOD with appropriate one to use for the scheduling
void periodicTimer() {
	int res;
	//set and activate a timer
	res = start_periodic_timer(OFFSET, PERIOD_TASK_SECOND);	//1s
//	res = start_periodic_timer(OFFSET, PERIOD_TASK_A);			//10ms
	if (res < 0 ){
		perror("Start periodic timer");
		return -1;
	}
	
	while (timerActive) {
		wait_next_activation(); //wait for timer expiration
		task_body(); //executes the task
		//printf("Total elapsed time: %f\n", (double)currentTime);
		printf("Total elapsed time double: %f\n", doubleCurrentTime);
	}
	
	return(NULL);
}

//---------------------From periodic task example--------------------
static void wait_next_activation(void) {
	int dummy;
	/* suspend calling process until a signal is pending */
	sigwait(&sigst, &dummy);
}

int start_periodic_timer(uint64_t offset, int period) {
	struct itimerspec timer_spec;
	struct sigevent sigev;
	timer_t timer;
	const int signal = SIGALRM;
	int res;
	
	/* set timer parameters */
	timer_spec.it_value.tv_sec = offset / ONE_MILLION;
	timer_spec.it_value.tv_nsec = (offset % ONE_MILLION) * ONE_THOUSAND;
	timer_spec.it_interval.tv_sec = period / ONE_MILLION;
	timer_spec.it_interval.tv_nsec = (period % ONE_MILLION) * ONE_THOUSAND;
	
	sigemptyset(&sigst); // initialize a signal set
	sigaddset(&sigst, signal); // add SIGALRM to the signal set
	sigprocmask(SIG_BLOCK, &sigst, NULL); //block the signal
	
	/* set the signal event a timer expiration */
	memset(&sigev, 0, sizeof(struct sigevent));
	sigev.sigev_notify = SIGEV_SIGNAL;
	sigev.sigev_signo = signal;
	
	/* create timer */
	res = timer_create(CLOCK_MONOTONIC, &sigev, &timer);
	
	if (res < 0) {
		perror("Timer Create");
		exit(-1);
	}
	
	/* activate the timer */
	return timer_settime(timer, 0, &timer_spec, NULL);
}

static void task_body(void) {
	static int cycles = 0;
	static uint64_t start;
	uint64_t current;
	struct timespec tv;
	
	if (start == 0) {
		clock_gettime(CLOCK_MONOTONIC, &tv);
		start = tv.tv_sec * ONE_THOUSAND + tv.tv_nsec / ONE_MILLION;
	}
	
	clock_gettime(CLOCK_MONOTONIC, &tv);
	current = tv.tv_sec * ONE_THOUSAND + tv.tv_nsec / ONE_MILLION;
	
	if (cycles > 0) {
		currentTime += (double)(current-start)/cycles;	//Keep track of time after periods
		doubleCurrentTime += (double)(current - start)/cycles; //TODO: Rename this to currentTime after testing
		printf("-----------------------------------------------\n");
		fprintf(stderr, "Ave interval between instances: %f millisecons\n", (double)(current-start)/cycles);
		printf("-----------------------------------------------\n");
	}
	
	cycles++;
}


